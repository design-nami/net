<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>nami</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #0040ff; }
    canvas { display: block; }
    #overlay-text {
      font-size: 24px;
      line-height: 1.6;
      position: absolute;
      top: 10px;
      left: 16px;
      color: white;
      font-family: sans-serif;
      white-space: pre-wrap;
      z-index: 1;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="overlay-text"><div style="font-size:48px; line-height:1.2; margin-bottom: 0;">nami</div><div style="font-size:24px; line-height:1.6; margin-top: 0;">Emerge, Amplify, Resonant</div>

Sorry, this site is still in preparation.
We’re deeply engaged in creating what comes next.
We’ve barely begun to archive our past.

A practice of speculative design —
questions into the world,
and prototypes you might want to join.

＿＿＿

Our process unfolds through 3 layers:
Emerge - awakening the unseen
Amplify - gathering momentum
Resonant - attuning relations


<u>info@design-nami.net</u>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 100;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0040ff); // 背景色を青に変更
    document.body.appendChild(renderer.domElement);

    const lineWidths = [1, 2, 3, 4];
    const totalLines = 150;

    const randomInRange = (min, max) => Math.random() * (max - min) + min;

    const randomDirection = (scale) => new THREE.Vector3(
      Math.random() - 0.5,
      Math.random() - 0.5,
      Math.random() - 0.5
    ).normalize().multiplyScalar(scale);

    const rotationSpeeds = [];
const lines = [];
for (let i = 0; i < totalLines; i++) {
      const isShort = Math.random() < 0.7;
      let length;
const sizeSelector = Math.random();
if (sizeSelector < 0.3) {
  // Size 1: 極小（4〜6）
  length = randomInRange(4, 6);
  rotationSpeeds.push(0.01);
} else if (sizeSelector < 0.6) {
  // Size 2: 小（7〜9）
  length = randomInRange(7, 9);
  rotationSpeeds.push(0.004);
} else if (sizeSelector < 0.9) {
  // Size 3: 中（10〜12）
  length = randomInRange(10, 12);
  rotationSpeeds.push(0.002);
} else {
  // Size 4: 大（13〜15）
  length = randomInRange(13, 15);
  rotationSpeeds.push(0.0008);
}

      const start = new THREE.Vector3(
        randomInRange(-50, 50),
        randomInRange(-50, 50),
        randomInRange(-50, 50)
      );

      const dir1 = randomDirection(length * randomInRange(0.2, 1.0));
      const mid1 = new THREE.Vector3().addVectors(start, dir1);

      const dir2 = randomDirection(length * randomInRange(0.2, 1.0));
      const mid2 = new THREE.Vector3().addVectors(mid1, dir2);

      const shapeType = i < 50 ? 1 : i % 4;
      let points;

      if (shapeType === 0) {
        points = [start, mid1];
      } else if (shapeType === 1) {
        points = [start, mid1, mid2];
      } else if (shapeType === 2) {
        const dir3 = randomDirection(length * randomInRange(0.2, 1.0));
        const mid3 = new THREE.Vector3().addVectors(mid2, dir3);
        const dir4 = randomDirection(length * randomInRange(0.2, 1.0));
        const end = new THREE.Vector3().addVectors(mid3, dir4);
        points = [start, mid1, mid2, mid3, end];
      } else {
        const dir3 = randomDirection(length * randomInRange(0.2, 1.0));
        const end = new THREE.Vector3().addVectors(mid2, dir3);
        points = [start, mid1, mid2, end];
      }

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: 0xffffff,
        linewidth: lineWidths[Math.floor(i / 25)]
      });

      const line = new THREE.Line(geometry, material);
      line.userData.rotationSpeed = rotationSpeeds[i];
      lines.push(line);
      scene.add(line);
    }

    function animate() {
      requestAnimationFrame(animate);
      lines.forEach(line => {
        line.rotation.y += line.userData.rotationSpeed;
      });
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
